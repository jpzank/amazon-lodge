import { parse } from 'csv-parse/sync';
import { readFileSync, writeFileSync } from 'fs';
import path from 'path';

interface CloudinaryImage {
  filename: string;
  url: string;
  tags: string;
}

interface ImageMapping {
  [category: string]: {
    [key: string]: string | { 
      id: string; 
      photographer?: string; 
      title?: string 
    };
  };
}

interface ProcessedImage {
  id: string;
  tags: string[];
  photographer?: string;
  title?: string;
}

// Special mappings for specific pages
const PAGE_MAPPINGS: { [key: string]: string[] } = {
  'home': ['Home', 'About'],
  'about': ['About'],
  'contact': ['Contact']
};

function normalizeImageName(filename: string): string {
  // Remove file extension and convert to kebab case
  return filename
    .replace(/\.[^/.]+$/, '')
    .toLowerCase()
    .replace(/_/g, '-');
}

function extractPhotographer(tags: string[]): string | undefined {
  const photographerTags = tags.filter(tag => 
    ['Marlon Erthal', 'Manoel Ruedi', 'Jhonata Araujo', 'Vincent Kurt Lo', 'Haroldo Palo Jr', 'JJ', 'Kiko Silva']
    .includes(tag)
  );
  return photographerTags[0];
}

function generateConfig() {
  try {
    // Read CSV file
    const csvContent = readFileSync(
      path.resolve(__dirname, '../src/config/CloudinaryImageList.csv'),
      'utf-8'
    );
    
    const records: CloudinaryImage[] = parse(csvContent, {
      columns: true,
      skip_empty_lines: true
    });

    // Process records
    const processedImages: ProcessedImage[] = records.map(record => ({
      id: record.filename,
      tags: record.tags.split(',').map(tag => tag.trim()),
      photographer: extractPhotographer(record.tags.split(',').map(tag => tag.trim()))
    }));

    // Group images by primary category
    const imagesByCategory: ImageMapping = {
      // Initialize special sections
      'home': {},
      'about': {}
    };
    
    processedImages.forEach((image) => {
      // Skip images without tags
      if (!image.tags.length) return;

      // Handle special page mappings first
      let categorized = false;
      for (const [page, tagList] of Object.entries(PAGE_MAPPINGS)) {
        if (image.tags.some(tag => tagList.includes(tag))) {
          if (!imagesByCategory[page]) {
            imagesByCategory[page] = {};
          }
          const imageName = normalizeImageName(image.id);
          if (image.photographer) {
            imagesByCategory[page][imageName] = {
              id: image.id,
              photographer: image.photographer
            };
          } else {
            imagesByCategory[page][imageName] = image.id;
          }
          categorized = true;
          break;
        }
      }

      // If not already categorized, use the first non-photographer tag
      if (!categorized) {
        const primaryCategory = image.tags
          .find(tag => !['Marlon Erthal', 'Manoel Ruedi', 'Jhonata Araujo', 'Vincent Kurt Lo', 'Haroldo Palo Jr', 'JJ', 'Kiko Silva']
          .includes(tag))?.toLowerCase().replace(/\s+/g, '-') || 'uncategorized';

        if (!imagesByCategory[primaryCategory]) {
          imagesByCategory[primaryCategory] = {};
        }

        const imageName = normalizeImageName(image.id);
        if (image.photographer) {
          imagesByCategory[primaryCategory][imageName] = {
            id: image.id,
            photographer: image.photographer
          };
        } else {
          imagesByCategory[primaryCategory][imageName] = image.id;
        }
      }
    });

    // Add default images if they don't exist
    if (!imagesByCategory.home['about-image']) {
      imagesByCategory.home['about-image'] = 'default_about_image';
    }

    // Generate JavaScript file
    const jsContent = `// Auto-generated from Cloudinary CSV export
// Do not edit this file directly - Generated on ${new Date().toISOString()}

import { Cloudinary } from '@cloudinary/url-gen';

export const cld = new Cloudinary({
  cloud: { cloudName: 'dxlhv2mji' }
});

export const CLOUDINARY_BASE_URL = 'https://res.cloudinary.com/dxlhv2mji/image/upload';
export const DEFAULT_TRANSFORMATIONS = 'f_auto,q_auto';

export const folderImageMapping = ${JSON.stringify(imagesByCategory, null, 2)};

export function getFolderImage(folder, imageName, transformations = DEFAULT_TRANSFORMATIONS) {
  const mapping = folderImageMapping[folder];
  if (!mapping) {
    console.warn(\`No folder mapping found for: \${folder}\`);
    return '';
  }

  const imageData = mapping[imageName];
  if (!imageData) {
    console.warn(\`No image mapping found for: \${imageName} in folder: \${folder}\`);
    return '';
  }

  const imageId = typeof imageData === 'string' ? imageData : imageData.id;
  return \`\${CLOUDINARY_BASE_URL}/\${transformations}/\${imageId}\`;
}

export function getImagePhotographer(folder, imageName) {
  const mapping = folderImageMapping[folder];
  if (!mapping) return undefined;

  const imageData = mapping[imageName];
  if (!imageData || typeof imageData === 'string') return undefined;

  return imageData.photographer;
}
`;

    // Generate TypeScript file
    const tsContent = `// Auto-generated from Cloudinary CSV export
// Do not edit this file directly - Generated on ${new Date().toISOString()}

import { Cloudinary } from '@cloudinary/url-gen';

export const cld = new Cloudinary({
  cloud: { cloudName: 'dxlhv2mji' }
});

export const CLOUDINARY_BASE_URL = 'https://res.cloudinary.com/dxlhv2mji/image/upload';
export const DEFAULT_TRANSFORMATIONS = 'f_auto,q_auto';

export const folderImageMapping = ${JSON.stringify(imagesByCategory, null, 2)} as const;

export function getFolderImage(
  folder: keyof typeof folderImageMapping, 
  imageName: string, 
  transformations: string = DEFAULT_TRANSFORMATIONS
): string {
  const mapping = folderImageMapping[folder];
  if (!mapping) {
    console.warn(\`No folder mapping found for: \${folder}\`);
    return '';
  }

  const imageData = mapping[imageName];
  if (!imageData) {
    console.warn(\`No image mapping found for: \${imageName} in folder: \${folder}\`);
    return '';
  }

  const imageId = typeof imageData === 'string' ? imageData : imageData.id;
  return \`\${CLOUDINARY_BASE_URL}/\${transformations}/\${imageId}\`;
}

export function getImagePhotographer(
  folder: keyof typeof folderImageMapping,
  imageName: string
): string | undefined {
  const mapping = folderImageMapping[folder];
  if (!mapping) return undefined;

  const imageData = mapping[imageName];
  if (!imageData || typeof imageData === 'string') return undefined;

  return imageData.photographer;
}

export type CloudinaryFolders = keyof typeof folderImageMapping;
export type CloudinaryImageNames<T extends CloudinaryFolders> = keyof typeof folderImageMapping[T];
`;

    // Write both files
    writeFileSync(
      path.resolve(__dirname, '../src/config/cloudinaryConfig.js'),
      jsContent
    );

    writeFileSync(
      path.resolve(__dirname, '../src/config/cloudinaryConfig.ts'),
      tsContent
    );

    console.log('Successfully generated Cloudinary configuration files!');
  } catch (error) {
    console.error('Error generating Cloudinary configuration:', error);
    process.exit(1);
  }
}

generateConfig(); 